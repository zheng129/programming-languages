

#### Programming languages that have been chosen (let me know if I missed some or change the file yourself and send me a pull request)


- [Haskell](https://github.com/Hazmatt101/CPSC354-programming-languages) (Matt McCortney)
- [Julia](https://github.com/lindn100/CPSC354-Blog) (Antoine Cannan, Ryan Lindner)
- [Solidity](https://github.com/cberardi4/Programming-Languages) (Christina Berardi, Ben Wasserman)
- [Go](https://github.com/GraysonBerman/GoLangRepo) (Grayson Berman, Parker Janke)
- [Swift](https://github.com/schwa184/Swift-Blog) (Majid Aziz, Matthew Schwab, Alfonso Castanos)
- [Haskell](https://github.com/brisenodaniel/Prgrm_Lang_Project) (Daniel Briseno, Colton Gering)
- [IBM Q](https://onp4.com/@kagan105/~cpsc354-final-project---trevor-kling-and-sam-kagan) (Sam Kagan, Trevor Kling) 
- [Fortran](https://arora110.wixsite.com/cpsc354) (Akash Arora)
- Javascript/JQuery (Monique Namsinh)
- [Rust and WebAssembly](https://github.com/tbalestra/RUST-and-Web-Assembly) (Theo Balestra, Rielle Dizon)
- [TypeScript](https://github.com/ereeq/proglangblog) (Eric Lim)
- [Elixir](https://github.com/ColeGotelli/Elixir) (Cole Gotelli, Nick Lai, Charlie Liu)
- [Ruby on Rails]( https://tommymadden.com/blog/programming_languages/index.php) (Brendan Forde, Tommy Madden)
- [Go](https://github.com/nfergie/PlBlog) (Nicole Fergie)
- Common Lisp (Gregory Albarian, Sabrina Toubbeh)
- [Haskell](https://yixingz.com/blog/) (Yixing Zheng)
- ... 


##### For the record: Programming languages that came up in the discussions

- Fortran/Algol (sth old), 
- Go, 
- PhP, 
- Q#, 
- Matlab, 
- Ruby on Rails, 
- Rust
- Scala
- Arduino
- ... probably some more ... 

one language I would like to add is 

- Elm which used to be based on [Functional Reactive Programming](https://en.wikipedia.org/wiki/Functional_reactive_programming), but [moved to a new architecture](http://elm-lang.org/blog/farewell-to-frp). Elm is a programming to implement reactive systems, which is related to a discussion we had in class of how to reconcile the idea of functional programming with the idea of not having just one input and one output but rather streams of inputs and outputs (and continue computing/reacting potentially forever)

there was also the question about using python for a machine learning project ... I think you need to be able to argue that your project contributes to learning sth new about Programming Languages ... so if you used machine learning to analyse the data on github in order to learn sth new about Programming Languages that could be possible ... so I add

- machine learning Programming Languages data

On Friday, I will present you a class of programming languages called theorem provers or proof assistants, where programs are mathematical proofs. Proof assistants are not only a tool in programming languages (see the course [concrete semantics](http://concrete-semantics.org) which teaches theorem proving and programming languages together), they are also a great way to learn more about logic from the point of view of a programmer (because you write proofs by writing programs). The proof assistant I will present is

- [Isabelle](https://isabelle.in.tum.de)

but there are also other ones such as Coq and Agda and, in particular, 

- [Idris](http://docs.idris-lang.org/en/latest/tutorial/index.html)

which is not only a proof assistant but also a fully fledged functional programming language about which it is said that Idris is what Haskell would look like if Haskell had been designed with dependent types. In my view Isabelle makes it easier to bring maths on the machine whereas Idris (and Coq and Agda) are a more natural starting point from a programmers perspective as they directly implement the the paradigm "proofs=programs".
